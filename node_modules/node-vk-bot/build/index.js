"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var rq = require("request-promise-native");
var fs = require("fs");
var UpdateToObj_1 = require("./functions/UpdateToObj");
var poll_1 = require("./functions/poll");
var Bot = (function (_super) {
    __extends(Bot, _super);
    function Bot(options) {
        var _this = _super.call(this) || this;
        _this.options = options;
        _this._events = {};
        _this._userEvents = [];
        _this._stop = false;
        if (!options.token)
            throw new Error('Token can\'t be empty');
        return _this;
    }
    Bot.prototype.api = function (method, params) {
        if (params === void 0) { params = {}; }
        var o = this.options;
        if (o.api) {
            params.v = params.v || o.api.v || 5.62;
            params.lang = params.lang || o.api.lang;
            if (params.lang == null)
                delete params.lang;
        }
        else
            params.v = params.v || 5.62;
        params.access_token = this.options.token;
        return rq({
            baseUrl: 'https://api.vk.com',
            uri: '/method/' + method,
            form: params,
            method: 'POST',
            json: true
        }).then(function (res) {
            if (/execute/.test(method)) {
                return res;
            }
            else if (res.error) {
                throw res.error;
            }
            return res.response;
        });
    };
    Bot.prototype.send = function (text, peer, params) {
        if (params === void 0) { params = {}; }
        params.message = params.message || text;
        params.peer_id = params.peer_id || peer;
        return this.api('messages.send', params);
    };
    Bot.prototype.start = function (poll_delay) {
        this.on('update', this._update);
        poll_1.default(this, poll_delay);
        return this;
    };
    Bot.prototype.stop = function () {
        this._stop = true;
        this.removeListener('update', this._update);
        this._events = {};
        return this;
    };
    Bot.prototype.get = function (pattern, listener) {
        this._userEvents.push({
            pattern: pattern, listener: listener
        });
        return this;
    };
    Bot.prototype.uploadPhoto = function (path) {
        var _this = this;
        return this.api('photos.getMessagesUploadServer')
            .then(function (server) { return rq({
            method: 'POST',
            uri: server.upload_url,
            formData: {
                photo: fs.createReadStream(path)
            },
            json: true
        }); })
            .then(function (upload) { return _this.api('photos.saveMessagesPhoto', {
            server: upload.server,
            photo: upload.photo,
            hash: upload.hash
        }); })
            .then(function (photos) { return photos[0]; });
    };
    Bot.prototype._update = function (update) {
        var text = update[6];
        var peer = update[3];
        var flag = update[2];
        var isChat = peer > 2e9;
        var isOutcoming = flag & 2;
        var hasAttachments = !!Object.keys(update[7]).length;
        if (!text && !hasAttachments)
            return;
        if (this.options.chats && this.options.chats.length && !this.options.chats.includes(peer))
            return;
        if (this.options.prefix) {
            var p = this.options.prefix;
            if (text.search(p) !== 0) {
                if (!this.options.prefixOnlyInChats)
                    return;
                if (this.options.prefixOnlyInChats && (isChat || isOutcoming))
                    return;
            }
        }
        else {
            if (isOutcoming)
                return;
        }
        var ev = this._userEvents.find(function (_a) {
            var pattern = _a.pattern;
            return pattern.test(text);
        });
        if (!ev) {
            this.emit('command-notfound', UpdateToObj_1.default(update));
            return;
        }
        ev.listener(UpdateToObj_1.default(update), ev.pattern.exec(text));
    };
    return Bot;
}(events_1.EventEmitter));
exports.Bot = Bot;
